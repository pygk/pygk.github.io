---
layout: custom
title: programers 억억단을 외우자
date: 2022-12-19 21:15:00 +0900
last_modified_at: 2022-12-19 10:23:00 +0900
category: algorithm
tags: ["programers", "dynamic programming"]
published: True

---
> programers - 억억단을 외우자 python 풀이

- 링크
    - [https://school.programmers.co.kr/learn/courses/30/lessons/138475](https://school.programmers.co.kr/learn/courses/30/lessons/138475)

- 문제
    - s <= x <= e 를 만족하는 수 중 억억단에 가장 많이 등장한 수 구하기
    - 예) s = 1, e = 8 (억억단에서 1 ~ 8이 등장하는 횟수)
        - 1: 1번 등장
        - 2: 2번 등장
        - 3: 2번 등장
        - 4: 3번 등장
        - 5: 2번 등장
        - 6: 4번 등장
        - 7: 2번 등장
        - 8: 4번 등장

- 풀이
    - 억억단에 등장한 수 == 약수
        - 1: 1번 등장 {1}
        - 2: 2번 등장 {1, 2}
        - 3: 2번 등장 {1, 3}
        - ...
        - 8: 4번 등장 {1, 2, 4, 8}

    - 약수의 개수를 효율적으로 구하는 것이 중요 (시간초과)
        - 시작 `starts` 는 각각 다르지만 끝 `e`는 변하지 않음 (1~e 까지의 약수 개수를 구한 후 변수에 저장)
        - 약수 개수 구하는 방법 참고 [https://school.programmers.co.kr/questions/40267](https://school.programmers.co.kr/questions/40267)
    
    - 억억단 행렬은 __대칭행렬__!
        - s = 1, e = 8 일 때의 행렬

        |<span style="color:red">1</span>|<span style="color:blue">2</span>|<span style="color:blue">3</span>|<span style="color:blue">4</span>|<span style="color:blue">5</span>|<span style="color:blue">…</span>|<span style="color:blue">8</span>|
        |<span style="color:blue">2</span>|<span style="color:red">4</span>|<span style="color:blue">6</span>|<span style="color:blue">8</span>|…|…|…|
        |<span style="color:blue">3</span>|<span style="color:blue">6</span>|…|…|…|…|…|
        |<span style="color:blue">4</span>|<span style="color:blue">8</span>|…|…|…|…|…|
        |<span style="color:blue">5</span>|…|…|…|…|…|…|
        |<span style="color:blue">…</span>|…|…|…|…|…|…|
        |<span style="color:blue">8</span>|…|…|…|…|…|…|
        
        - 아래 코드는 위 행렬에서의 <span style="color:blue">파란</span> 부분의 개수를 구하는 과정
            ```python
            for i in range(2, e+1):
                for j in range(1, min(e//i+1, i)):
                    divisor[i*j] += 2
            ```

        - 아래 코드는 위 행렬에서의 <span style="color:red">빨간</span> 부분의 개수를 구하는 과정
            ```python
            for i in range(1, int(e**(1/2))+1):
                divisor[i**2] += 1
            ```

- 전체 코드
    ```python
    def solution(e, starts):
        # 약수 개수 구하기
        divisor = [0 for _ in range(e+1)]
        for i in range(2, e+1):
            for j in range(1, min(e//i+1, i)):
                divisor[i*j] += 2
        for i in range(1, int(e**(1/2))+1):
            divisor[i**2] += 1
        
        # 약수 개수 기준 내림차순, 인덱스 기준 오름차순 정렬
        sorted_divisor = sorted(
            [(v, i) for (i, v) in enumerate(divisor)],
            key = lambda x: (-x[0], x[1]))
        
        # s <= x <= e 를 만족하는 첫 번째 수 탐색
        answer = []
        for s in starts:
            for (v, i) in sorted_divisor:
                if s <= i and i <= e:
                    answer.append(i)
                    break
        return answer
```